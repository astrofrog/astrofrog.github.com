<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[.py in the sky]]></title>
  <link href="http://astrofrog.github.com/atom.xml" rel="self"/>
  <link href="http://astrofrog.github.com/"/>
  <updated>2013-04-10T21:24:18+02:00</updated>
  <id>http://astrofrog.github.com/</id>
  <author>
    <name><![CDATA[Thomas Robitaille]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to conduct a full code review on GitHub]]></title>
    <link href="http://astrofrog.github.com/blog/2013/04/10/how-to-conduct-a-full-code-review-on-github/"/>
    <updated>2013-04-10T13:38:00+02:00</updated>
    <id>http://astrofrog.github.com/blog/2013/04/10/how-to-conduct-a-full-code-review-on-github</id>
    <content type="html"><![CDATA[<h2>Why we might want to do it</h2>

<p>I think it&#8217;s fair to say I&#8217;m addicted to using
<a href="http://www.github.com">GitHub</a>. I&#8217;ve used it so much in the last couple of
years that I don&#8217;t understand/remember how we got any serious collaborative
coding done before. In particular, the ability to comment on code
line-by-line, having conversations, updating the pull requests, and merging
them with a single click is in my mind so much more rewarding and productive
than having to comment on a patch in an email discussion.</p>

<p>However, I occasionally want to do a full review of a package that someone
else has written, and comment on various parts of the code. While it is
possible to leave line-by-line comments on a commit-by-commit basis, GitHub
does not provide an official way to review the latest <em>full</em> version of a file
or package.</p>

<p>There are a few ways to conduct a full code review that I can think of:</p>

<ol>
<li><p>Browse through the files, on GitHub or locally, and open new issues
for anything we would like to comment on, copying and pasting the relevant
code. Not ideal if we want to comment on 20-30 chunks of code or more!</p></li>
<li><p>Browse through the files on GitHub, and if we see a line we want to comment
on, we can go to the <em>Blame</em> tab, and then find the last commit that
modified that line, and comment on it. The issue with this is that we might
want to comment on a chunk of code that was the result of several commits in
which case this method breaks down.</p></li>
<li><p>Leverage the pull request interface, with a little git-<em>fu</em>, to conduct a
proper full code review. This is in my opinion the best approach, and in
this post, I describe one way to do this. There may be more elegant ways, so
please let me know if you have any suggestions!</p></li>
</ol>


<h2>How to do it</h2>

<p>Ideally, one could simply create an empty branch on GitHub, then set up a pull
request from <code>master</code> (or whatever branch you want to review) onto the empty
branch. However, as far as I can tell, you can&#8217;t create completely empty
branches on GitHub - instead, we need our empty branch to have at least one
commit, which needs to match the first commit of the branch we want to review
(otherwise GitHub will complain that there is no common history).</p>

<p>So how we proceed depends on whether the first commit contains code that needs
to be reviewed, or if it is unimportant (for example, a lot of repositories
start with the addition of an empty README file).</p>

<h3>If the first commit is unimportant&#8230;</h3>

<p>&#8230; then the situation is fairly easy. You first need to find out the commit
hash for the first commit in the repository, which you can do with:</p>

<pre><code>$ git rev-list --all | tail -1
ec2287e5837386c54fbd082021530aa18c0dcf18
</code></pre>

<p>In the example above the hash is <code>ec2287e5837386c54fbd082021530aa18c0dcf18</code>,
but this will be different for you. Now, create an empty branch containing
only that commit:</p>

<pre><code>$ git branch empty ec2287e5837386c54fbd082021530aa18c0dcf18
</code></pre>

<p>This will create, but not switch to, the empty branch. Next push your
<code>empty</code> branch to GitHub:</p>

<pre><code>$ git push origin empty
</code></pre>

<p>Go to your repository on GitHub and click on the &#8216;Pull Request&#8217; button at the
top right of the window:</p>

<p><img class="center" src="http://astrofrog.github.com/images/code_review/pull_request_1.png"></p>

<p>Then set it up so that you are pulling the changes from <code>master</code> into
<code>empty</code>, as follows:</p>

<p><img class="center" src="http://astrofrog.github.com/images/code_review/pull_request_2.png"></p>

<p>You can now enter a title and message for the pull request, and invite other
people to comment on the code. If you make changes to <code>master</code>, you can
simply push the changes to GitHub as usual:</p>

<pre><code>$ git push origin master
</code></pre>

<p>which should cause the new commits to appear in the pull request. Once the
review is complete, you can just close the pull request (without merging), and
keep the empty branch for future reviews (or delete it).</p>

<h3>If the first commit is important&#8230;</h3>

<p>&#8230; this makes things a little more complicated. The approach we&#8217;ll take here
is to create two new branches - <code>review</code>, containing the code to review, and
<code>empty</code>, containing no files - both of which contain a common and empty
first commit (which we will add). In this way, the two branches have a common
history, even though the <code>empty</code> branch has no files. We can set then set up
a pull request from <code>review</code> to <code>empty</code>.</p>

<p><strong>Important disclaimer</strong>: make sure that you make a backup of your repository,
and that there are no unsaved changes! If you follow these instructions, any
files that are not already in the repository <em>will</em> get deleted, as well as
any uncommitted changes! In fact, it might be safest to do this in a clean
clone of your repository, so that if anything goes wrong, you haven&#8217;t affected
your usual work repository.</p>

<p>With that disclaimer in mind, go to the repository you want to do a review
for, and then create an empty branch that we will call <code>review</code></p>

<pre><code>$ git checkout --orphan review
</code></pre>

<p>This branch has no history, but the files should still be there and would be
added to the branch if we were to commit. However, you don&#8217;t want to do this,
so remove all the files in the repository in the current branch by first
unstaging all the files:</p>

<pre><code>$ git rm -r --cached *
</code></pre>

<p>then removing them all:</p>

<pre><code>$ git clean -fxd
</code></pre>

<p>Note that any file that was not previously part of the repository will be
deleted for good, not just from this branch!</p>

<p>You should now have a nice and empty branch:</p>

<pre><code>$ git log
fatal: bad default revision 'HEAD'

$ git status
# On branch review
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)
</code></pre>

<p>You are now ready to set up the review. You should first add a dummy commit
that contains no files:</p>

<pre><code>$ git commit --allow-empty -m "Start of the review"
</code></pre>

<p>Then create a new branch called <code>empty</code> that will contain only this commit:</p>

<pre><code>$ git branch empty
</code></pre>

<p>This will create a branch with the same empty commit, but will keep on the
<code>review</code> branch. You can now merge in the changes from the branch we want to
actually review, say <code>master</code>, into <code>review</code>:</p>

<pre><code>$ git merge master
</code></pre>

<p>You will be asked to provide a merge commit message, and you can just leave
the default. Next push your <code>review</code> and <code>empty</code> branches to GitHub:</p>

<pre><code>$ git push origin review
$ git push origin empty
</code></pre>

<p>Go to your repository on GitHub and click on the &#8216;Pull Request&#8217; button at the
top right of the window:</p>

<p><img class="center" src="http://astrofrog.github.com/images/code_review/pull_request_1.png"></p>

<p>Then set it up so that you are pulling the changes from <code>review</code> into
<code>empty</code>, as follows:</p>

<p><img class="center" src="http://astrofrog.github.com/images/code_review/pull_request_3.png"></p>

<p>You can now enter a title and message for the pull request, and invite other
people to comment on the code. Make sure that you switch back to your
<code>master</code> (or other) branch to implement the changes, and if you then want to
update the review pull request, you can switch back to <code>review</code> and merge
the latest changes from <code>master</code>:</p>

<pre><code>$ git checkout review
$ git merge master
$ git push origin review
</code></pre>

<p>which should cause the new commits to appear in the pull request.</p>

<h2>Epilogue</h2>

<p>As you can see, if the first commit in your repository is unimportant, things
are actually pretty straightforward. I&#8217;d love to hear if anyone has a better
way to deal with the case where we want to review all commits, including the
first. Finally, if any GitHub employees are reading this - please make it
easier for people to conduct full reviews! :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Python installations are scientists using?]]></title>
    <link href="http://astrofrog.github.com/blog/2013/01/13/what-python-installations-are-scientists-using/"/>
    <updated>2013-01-13T10:10:00+01:00</updated>
    <id>http://astrofrog.github.com/blog/2013/01/13/what-python-installations-are-scientists-using</id>
    <content type="html"><![CDATA[<p>Back in November 2012, I
<a href="https://twitter.com/astrofrog/status/269743084215103488">asked</a> Python
users in Science to fill out a survey to find out what <a href="http://www.python.org">Python</a>, <a href="http://www.numpy.org">Numpy</a>, and
<a href="http://www.scipy.org">Scipy</a> versions they were using, and how they maintain their installation. My motivation for this was to collect quantitative
information to inform discussions amongst developers regarding which versions
to support, because those discussions are usually based only on guessing and
personal experience. In particular, there has been some discussion in the
<a href="http://www.astropy.org">Astropy</a> project regarding whether we should drop
support for Numpy 1.4, but we had no quantitative information about whether
this would affect many users (which motivated this study).</p>

<p>In this post, I&#8217;ll give an overview of the results, as well as access to the
(anonymized) raw data. First, I should mention that given my area of research
and networks, the only community I obtained significant data are Astronomers,
so the results I present here only include these (though I also provide the
raw data for the remaining users for anyone interested).</p>

<!-- more -->


<p>Before I show the results, I just want to make it clear that I am not claiming
that the results are a true sampling of Python user levels. I advertised the
poll via Twitter, a couple of Python mailing lists, and the Facebook group for
Astronomers. The survey was announced on different days on Twitter and
Facebook, so there may be some useful information about the typical Python
installations of Twitter vs Facebook users buried in the data that I won&#8217;t
cover here. If anyone is interested about when the announcements were made, to
correlate with response peaks in the data, please let me know!</p>

<p>With that out of the way&#8230; let&#8217;s look at the results!</p>

<h2>Overview</h2>

<p>First, some general stats - there were 313 responses in total, of which 244
were related to Astronomy (where I use the term in the broadest sense,
including solar physics, planetary science, astrophysics, and cosmology). The
responses were recorded between November 17th 2012 and December 2nd 2012 (at
which point the rate of responses had gone down to less than one a day).</p>

<h2>Python Versions</h2>

<p><img class="center" src="http://astrofrog.github.com/images/python_versions.png"></p>

<p>As shown above, an overwhelming 80% of Astronomers use Python 2.7, and almost
15% use Python 2.6. Almost no-one uses Python 3.x for production work yet,
which is not surprising, given that at the time of the poll there were not
stable versions for all the crucial packages in a scientific Python stack (in
particular, Matplotlib only released their first Python 3.x compatible release
in December). It will be interesting to see how this fraction changes over the
next year (more on that in future blog posts).</p>

<h2>Numpy Versions</h2>

<p><img class="center" src="http://astrofrog.github.com/images/numpy_versions.png"></p>

<p>In the above plot, <em>dev</em> includes anything that is a developer version more
recent than the 1.6.2 release (which was the latest stable release at the time
of the poll). The distribution is again significantly peaked, with almost 80%
of respondents using Numpy 1.6.x. There is more of a spread in the remaining
versions compared with the Python versions, but the vast majority of people
are using Numpy 1.5.x or more recent.</p>

<h2>Scipy Versions</h2>

<p><img class="center" src="http://astrofrog.github.com/images/scipy_versions.png"></p>

<p>In the above plot, <em>dev</em> includes anything that is a developer version more
recent than the stable 0.11 release (which was the latest stable release at
the time of the poll). Unlike the Python and Numpy versions, which are almost
exclusively dominated by two versions, the Scipy versions show a larger
spread, with the most popular version, 0.10.x, representing less than 45% of
users.</p>

<p>I originally thought that Scipy released more often than Numpy, and this would
explain the difference, but it seems that both projects have been releasing at
a reasonably similar rate (see
<a href="http://sourceforge.net/projects/numpy/files/NumPy/">here</a> and
<a href="http://sourceforge.net/projects/scipy/files/scipy/">here</a>). Therefore, this
might be to do with package managers, or simply to the fact that Numpy is used
more often than Scipy, and users are therefore more likely to run into bugs
and update to the latest stable version? I have to admit that I would not even
be able to tell without checking what Scipy version I am using, whereas I know
I&#8217;m using Numpy 1.6.2 for production work.</p>

<h2>Installation</h2>

<p>We now get to some very interesting statistics - how users install Python and
dependencies. While Python is awesome in many respects, installation is
probably the biggest hurdle that users have to jump to get started.</p>

<p><img class="center" src="http://astrofrog.github.com/images/install_methods.png"></p>

<p>I&#8217;m not sure if anyone&#8217;s quantitatively looked at this before, but this was
the first time that I really got a sense for all the different ways that one
can maintain a Python installation, and which methods are the most popular. The options shown above are described below:</p>

<p><em>Linux Manager</em> means linux package managers (<code>apt-get</code>, <code>yum</code>, etc.)
<em>Source</em> means an installation from the source code. This means either
downloading the source code and running <code>python setup.py install</code>, or using
<code>pip install</code> or <code>easy_install</code>.
<em>EPD</em> stands for the
  <a href="http://www.enthought.com/products/epd.php">Enthought Python Distribution</a>,
which is a scientific Python bundle that includes e.g. Numpy, Scipy,
Matplotlib, and many other packages. It is free for users at academic
institutions.
<a href="http://www.macports.org"><em>MacPorts</em></a> is one of the most widely used package
managers on Mac, and I have provided instructions for getting set up with
Python and MacPorts <a href="http://astrofrog.github.com/macports-python/">here</a>.
<em>Official Installers</em> refers to the MacOS X disk images, Linux RPMs, and
Windows installers that are provided by some projects (including Python
itself, Numpy, and Scipy).
<em>Admins</em> means that Python and the packages were installed by System Administrators.
<a href="http://www.eso.org/sci/software/scisoft/"><em>SciSoft</em></a> and <a href="http://www.stsci.edu/institute/software_hardware/pyraf/stsci_python/current/stsci-python-download"><em>STScI Python</em></a> are two Astronomy-specific software bundles.
And <a href="http://www.activestate.com/activepython"><em>ActivePython</em></a> is similar to
EPD, but where binary packages are downloaded on-the-fly as needed.</p>

<p>Of course, some of these are not orthogonal, because for example
<code>easy_install</code> can be used to install additional packages not in EPD. But
the responses from the survey refer to how the main packages (Python, Numpy,
and Scipy) were installed.</p>

<p>What can we take away from the results?</p>

<ul>
<li><p>If we combine the Linux Package Managers and MacPorts (one of the Mac
Package Managers) into a more general <em>Package Managers</em> category, this
amounts to around 40% of users, the single largest group.</p></li>
<li><p>Only a small fraction of people use the official binary installers, with
many more people installing from source. This was surprising to me, given
how quick/easy it is to install Python, Numpy, Scipy, and Matplotlib using
the official installers. I think this is down to the fact that this is not a
well-documented installation procedure, and is platform dependent.</p></li>
<li><p>Astronomy-specific bundles (SciSoft and STScI Python) are not as widely
used, which indicates that more effort should be put in getting packages in
existing package managers than building new software bundles.</p></li>
<li><p>A small fraction (around 7%) have no idea how they installed Python and
other packages, so they may run into issues when they try and upgrade in
future. If you install Python for someone, please explain to them what you
are doing and how they can update packages in future!</p></li>
</ul>


<p>I personally feel that we should encourage users to install Python and
whatever dependencies are available from package managers. Of course, in some
cases users don&#8217;t have root access, but this generally means that they have
sysadmins, so in those cases, the best option is still for the sysadmins to
install the main Python packages via package managers.</p>

<h2>Summary</h2>

<p>To me, one of the most interesting results is that a large number of people
have a reasonably up-to-date installation, with Python 2.7 and Numpy 1.6.x,
and I imagine that the Python 2.7 peak is here to stay, given that the
transition to Python 3 will be slow.</p>

<p>For developers, supporting only Python 2.6 and above seems like a sensible
choice at this stage (a decision we made within Astropy), and given the
imminent release of Numpy 1.7.0, I think that developers can start thinking
about dropping support for Numpy 1.4 in the near future. For Scipy, things are
a little more difficult, given the broad spread of versions, so developers
should ensure that they know what versions they are implicitly supporting, and
to check what version users have installed.</p>

<p>In terms of installation method, I think it&#8217;s very important to ensure that
packages are included in package managers. Even if it is easy to install
packages via <code>pip</code> or <code>easy_install</code> in some cases, putting packages in
package managers ensures that users will more likely stay up-to-date with the
most recent versions.</p>

<p>There is more information still contained in the data than I covered here (for
example, some of the above points can be correlated - do the people who do not
know how they installed Python correlate with the older versions?). For anyone
who is interested in looking at the data, I&#8217;ve placed the files and the
scripts I used to make the above plots in a GitHub repository
<a href="https://github.com/astrofrog/python-versions-survey">here</a>.</p>

<p>If you have any thoughts about the results, or find anything interesting in
the raw data, please leave a comment!</p>
]]></content>
  </entry>
  
</feed>
